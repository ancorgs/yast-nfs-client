/**
 * File:
 *   Nfs.ycp
 *
 * Module:
 *   Configuration of nfs
 *
 * Summary:
 *   NFS client configuration data, I/O functions.
 *
 * Authors:
 *   Jan Holesovsky <kendy@suse.cz>
 *   Dan Vesely <dan@suse.cz>
 *   Martin Vidner <mvidner@suse.cz>
 *
 * $Id$
 */

{
    module "Nfs";

    textdomain "nfs";

    import "Report";
    import "Runlevel";
    import "Summary";

    /**
     * eg.: [ $["spec": "moon:/cheese", file: "/mooncheese", "mntopts": "defaults"], ...]
     */
    global list(map) nfs_entries = [];

    /**
     * Read only, intended for checking mount-point uniqueness.
     */
    global list(map) non_nfs_entries = [];

    /**
     * Get all NFS configuration from a map.
     * When called by nfs_auto (preparing autoinstallation data)
     * the map may be empty.
     * @param settings	a map with a single key: nfs_entries
     * @return	success
     */
    global define boolean Import (list settings) ``{
	if (size(settings) == 0)
	{
	    return true;
	}

	boolean missing = false;
	foreach(`s,settings,``{
	    foreach (`k, ["server_path", "mount_point", "nfs_options"], ``{
		if (! haskey (s, k))
		{
		    y2error ("Missing at Import: '%1'.", k);
		    missing = true;
		}
	    });
	});
	if (missing)
	{
	    return false;
	}

	Set(settings);
	return true;
    }

    /**
     * Set module data
     * @param settings module settings
     * @return void
     */
    global define void Set(list settings) ``{
	nfs_entries = maplist(map entry, settings, ``{
	    return($[
		     "spec":entry["server_path"]:"",
		     "file":entry["mount_point"]:"",
		     "mntops":entry["nfs_options"]:""
		   ]);
	});
	return;
    }

    /**
     * Dump the NFS settings to a map, for autoinstallation use.
     * @return a list of nfs entries.
     */
    global define list Export () ``{
	list entries = maplist(map entry, nfs_entries, ``{
		return($[
			"server_path":entry["spec"]:"",
			"mount_point":entry["file"]:"",
			"nfs_options":entry["mntops"]:""
			]);
	});
	return  entries;
    }

    /* ------------------------------------------------------------ */
    // Space escaping.
    // This should be done by the agent, but any-agent sucks.

    /**
     * Escape spaces " " -> "\\040" in all values of all entries
     * @param entries a list of maps, such as nfs_entries
     * @return escaped entries
     */
    define list(map) EscapeSpaces (list(map) entries) ``{
	return maplist (map entry, entries, ``(
			    mapmap (string key, string value, entry, ``(
					[ key,
					  is (value, string)?
					  EscapeSpaces1 (value): value ]
					))
			    ));
    }

    /**
     * Escape spaces " " -> "\\040".
     * @param s a string or nil
     * @return escaped string or nil
     */
    define string EscapeSpaces1 (string s) ``{
	return s == nil ? nil : mergestring (splitstring (s, " "), "\\040");
    }

    /**
     * Un-escape spaces "\\040" -> " " in all values of all entries
     * @param entries a list of maps, such as nfs_entries
     * @return escaped entries
     */
    define list(map) UnescapeSpaces (list(map) entries) ``{
	return maplist (map entry, entries, ``(
			    mapmap (string key, string value, entry, ``(
					[ key,
					  is (value, string)?
					  UnescapeSpaces1 (value): value ]
					))
			    ));
    }

    /**
     * Un-escape spaces "\\040" -> " "
     * @param a string or nil
     * @return escaped string or nil
     */
    define string UnescapeSpaces1 (string s) ``{
	// escaped space, \040, is /\\040/
	// which is "\\\\040"
	return s == nil ? nil : gsub ("\\\\040", " ", s);
    }

    /**
     * (like awk gsub, but return the result, not number of replacements)
     * replaces from back!
     */
    define string gsub (string regex, string replacement, string s) ``{
	string temp = nil;
	while (true)
	{
	    // argh, regexpsub logs an error if it cannot sub
	    if (! regexpmatch (s, ".*" + regex + ".*"))
	    {
		break;
	    }
	    temp = regexpsub (s, "(.*)"+regex+"(.*)", "\\1"+replacement+"\\2");
	    if (temp == nil)
	    {
		break;
	    }
	    s = temp;
	}
	return s;
    }

    /* ------------------------------------------------------------ */

    /**
     * Reads NFS settings from the SCR (.etc.fstab)
     * @return true on success
     */
    global define boolean Read () ``{
	list(map) fstab = SCR::Read (.etc.fstab);
	fstab = UnescapeSpaces (fstab);

	// For simplicity, this leaves also the unused fileds in the maps.
	nfs_entries = filter (map entry, fstab, ``{
	    return (entry["vfstype"]:"" == "nfs");
	});
	non_nfs_entries = filter (map entry, fstab, ``{
	    return (entry["vfstype"]:"" != "nfs");
	});

	return true;
    }

    /**
     * Writes the NFS client configuration and starts/stops the service.
     * (No parameters because it is too short to abort)
     * @return true on success
     */
    global define boolean Write () ``{
	if (WriteOnly ())
	{
	    Runlevel::RunInitScript ("nfs", "stop");
	    if (size (nfs_entries) > 0)
	    {
		if (Runlevel::ServiceStatus ("portmap") != 0)
		{
		    // portmap must not be started if it is running already (see bug # 9999)
		    Runlevel::RunInitScript ("portmap", "start");
		}
		Runlevel::RunInitScript ("nfs", "start");

		if (Runlevel::ServiceStatus ("nfs") != 0)
		{
		    // error popup message
		    Report::Error (_("Unable to mount the NFS entries from /etc/fstab."));
		    return false;
		}
	    }
	    return true;
	}
	else
	{
	    return false;
	}
    }
    /**
     * Writes the NFS client configuration without
     * starting/stopping the service.
     * Autoinstallation uses this and then calls SuSEconfig only once
     * and starts the services together.
     * (No parameters because it is too short to abort)
     * @return true on success
     */
    global define boolean WriteOnly () ``{
	// Merge with non-nfs entries from fstab:
	list(map) fstab = SCR::Read (.etc.fstab);
	// unescape deferred for optimization
	fstab = filter (map entry, fstab, ``{
	    return (entry["vfstype"]:"" != "nfs");
	});
	fstab = UnescapeSpaces (fstab);
	foreach (map entry, nfs_entries, ``{
	    fstab = add (fstab, union (entry, $["vfstype": "nfs", "freq": 0, "passno": 0]));

	    // create mount points
	    string file = entry["file"]:"";
	    if (! SCR::Execute (.target.mkdir, file))
	    {
		// error popup message
		Report::Warning (sformat (_("Unable to create directory '%1'."), file));
	    }
	});


	SCR::Execute (.target.bash, "/bin/cp $ORIG $BACKUP", $["ORIG" : "/etc/fstab", "BACKUP" : "/etc/fstab.YaST2.save"]);

	fstab = EscapeSpaces (fstab);
	if (!SCR::Write(.etc.fstab, fstab))
	{
	    // error popup message
	    Report::Error (_("Unable to write to /etc/fstab.
No  changes will be made to the
the NFS client configuration.\n"));
	    return false;
	}

	if (size (nfs_entries) == 0)
	{
	    //Runlevel::ServiceAdjust ("nfs", "disable"); // what if autofs needs it?
	}
	else
	{
	    Runlevel::ServiceAdjust ("portmap", "enable");
	    Runlevel::ServiceAdjust ("nfs", "enable");
	}

	return true;
    }

    /**
     * Summary()
     * @return Html formatted configuration summary
     */
    global define string Summary () ``{
	string summary = "";
	string nc = Summary::NotConfigured ();
	// summary header
	summary = Summary::AddHeader(summary, _("NFS entries"));
	integer entries = size(nfs_entries);
	y2milestone("Entries: %1", nfs_entries);
	string configured = sformat("%1 entries configured.", entries);
	summary = Summary::AddLine(summary, (entries>0) ? configured :  nc);
	return summary;
    }
}
