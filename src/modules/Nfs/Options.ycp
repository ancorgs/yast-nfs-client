{

module "Nfs::Options";
textdomain "nfs";

/**
 * Checks the nfs options for /etc/fstab:
 * nonempty, comma separated list of foo,nofoo,bar=baz (see nfs(5))
 * @param options   options
 * @return          a translated string with error message, emtpy string if ok
 */
global define string validate (string options) {
    // To translators: error popup
    if (size (options) == 0)   return _("Empty option strings are not allowed.");
    if (options == "defaults") return "";


    list<string> option_list = splitstring (options, ",");

    //the options must be easy to sync with mount.c and nfsmount.c

    // these can be negated by "no"
    list<string> non_value   = ["bg", "fg", "soft", "hard", "intr", "posix", "cto", "ac", "acl",
    		    "lock", "tcp", "udp", "rdirplus",
    		    // these are common for all fs types
    		    "atime", "auto", "dev", "exec", "group", "owner",
    			    "suid", "user", "users"];
    // these cannot be negated
    // they are not nfs specific BTW
    list non_value1 = ["defaults", "async", "sync", "dirsync", "ro", "rw",
    		   "remount", "bind", "rbind", "_netdev", ];
    list with_value  = ["rsize", "wsize", "timeo", "retrans", "acregmin", "acregmax",
    		    "acdirmin", "acdirmin", "acdirmax", "actimeo", "retry", "namlen",
    		    "port", "proto", "clientaddr", "mountport", "mounthost",
    		    "mountprog", "mountvers", "nfsprog", "nfsvers", "vers", "minorversion",
                        "sec" ];
    integer i = 0;
    string current_option = "";

    // first fiter out non value options and its nooptions forms (see nfs(5))
    option_list = filter (string e, option_list, ``(!contains (non_value, e)));
    non_value   = maplist (string e, non_value, ``(sformat ("no%1", e)));
    option_list = filter (string e, option_list, ``(!contains (non_value, e)));
    option_list = filter (string e, option_list, ``(!contains (non_value1, e)));

    while (i < size (option_list))
    {
        string opt = option_list[i]:"";
        list<string> value = splitstring (opt, "=");
        string v0 = value[0]:"";
        string v1 = value[1]:"";
        // FIXME: this also triggers for "intr=bogus"
        // To translators: error popup
        if (!contains (with_value, v0)) return sformat (_("Unknown option: %1"), v0);
        // To translators: error popup
        if (size (value) != 2) return sformat (_("Invalid option: %1"), opt);
        // To translators: error popup
        if (v1 == "") return sformat (_("Empty value for option: %1"), v0);
        i = i + 1;
    }

    return "";
}

/**
FIXME: factor out get_nfs4(vfstype, options) (depending on n::o)!
 * @return is version >= 4.1 enabled
 */
global boolean get_nfs41(string options) {
    list<string> option_list = splitstring (options, ",");

    return contains(option_list, "minorversion=1");
}

/**
 * Add or remove minorversion=1 according to nfs41.
 * FIXME vfstype=nfs4 is deprecated in favor of nfsvers=4 (aka vers=4)
 */
global define string set_nfs41(string options, boolean nfs41) {
    // don't mutate the string unnecessarily
    if (get_nfs41(options) == nfs41) {
        return options;
    }

    const string OPT   = "minorversion=1";
    const string CLEAN = "minorversion=0";

    if (options == "defaults") { options = ""; }
    list<string> option_list = splitstring(options, ",");
    option_list = filter(string opt, option_list, ``( opt != OPT ));
    option_list = filter(string opt, option_list, ``( opt != CLEAN ));

    if (nfs41) {
        option_list = add(option_list, OPT);
    }

    options = mergestring(option_list, ",");
    if (options == "") { options = "defaults"; }

    return options;
}

/*EOF*/
}
