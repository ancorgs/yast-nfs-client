/**
 * File:
 *   routines.ycp
 *
 * Module:
 *   Configuration of nfs
 *
 * Summary:
 *   Network NFS routines
 *
 * Authors:
 *   Jan Holesovsky <kendy@suse.cz>
 *   Dan Vesely <dan@suse.cz>
 *
 * $Id$
 *
 * Network NFS routines
 *
 */

{
    textdomain "nfs";

    include "ui/common_popups.ycp";

    /**
     * Creates a list of ui table items for nfs fstab entries
     * @param fstab	list of nfs fstab entries
     * @return		itemized table entries
     * @example UI::ChangeWidget(`id(`fstable), `Items, FstabTableItems(nfs_fstab));
     */
    global define list(term) FstabTableItems(list(map) fstab) ``{
	integer count = 0;
	return maplist(`entry, fstab, ``{
	    term sp = SpecToServPath(lookup(entry, "spec", ""));
	    term it = `item(`id(count),
			    select(sp, 0, "")+" ",
			    select(sp, 1, "")+" ",
			    lookup(entry, "file", "")+" ",
			    lookup(entry, "mntops", "")+" ");

	    count = count+1;
	    return it;
	});
    }

    /**
     * @param spec	"server:/path/specification"
     * @return		`couple("server", "/path/specification")
     */
    global define term SpecToServPath(string spec) ``{
	integer colonpos = findfirstof(spec, ":");
	string serv = "";
	if (colonpos != nil) {
	    serv = substring(spec, 0, colonpos);
	    spec = substring(spec, colonpos+1);
	}
	return `couple(serv, spec);
    }


    /**
     * Check for the validity of a hostname: nonempty, shorter than 50 chars,
     * [-A-Za-z._]. If invalid, a message is displayed.
     * @param name	a hostname
     * @return		whether valid
     */
    global define boolean CheckHostName(string name) ``{
	if (size(name) > 0 &&
	    size(name) < 50 &&
	    name == filterchars(name,
				"-_.0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")) {
	    return true;
	} else
	    // error popup message
	    UI::MessagePopup(sformat(_("You entered a wrong host name. It must be
shorter than 50 characters and you can use
just 0..9, A..Z, a..z, dots, - and _.")));
	return false;
    };

    /**
     * Check if a mountpoint is in the fstab. If yes, display a message.
     * @param fstab	in .etc.fstab format (must contain the key "file")
     * @param mpoint	mount point
     */
    global define boolean IsMpInFstab(list(map) fstab, string mpoint) ``{
	list tmp = filter(`fse, fstab, ``{
	    return (lookup(fse, "file", "") == mpoint);
	});

	if (size(tmp) == 0)
	    return false;
	else
	    // error popup message
	    UI::MessagePopup(sformat(_("The fstab already contains an entry
with mount-point '%1'."), mpoint));
	return true;
    };

    // duplicated in nfs/routines.ycp and nfs_server/routines.ycp
    /**
     * Check for the validity of a path/mountpoint:
     * nonempty, fewer than 70 chars, no blanks, starts with a slash.
     * If invalid, a message is displayed.
     * @param name	path
     * @return		whether valid
     */
    global define boolean CheckPath(string name) ``{
	if (size(name) > 0 &&
	    size(name) < 70 &&
	    substring(name, 0, 1) == "/" &&
	    findfirstof(name, " \t") == nil)
	    return true;
	else
	    // error popup message
	    UI::MessagePopup(sformat(_("You entered a wrong path. It must be
shorter than 70 characters, it must begin
with a / and it must not contain spaces.")));
	return false;
    };

    /**
     * Checks the nfs options for /etc/fstab:
     * nonempty, comma separated list of foo,nofoo,bar=baz (see nfs(5))
     * @param options	options
     * @return		a translated string with error message, emtpy string if ok
     */
    global define string check_options (string options) ``{

	// To translators: error popup
	if (size (options) == 0)   return _("Empty options string not allowed!");
	if (options == "defaults") return "";


	list option_list = splitstring (options, ",");
	// these can be negated by "no"
	list non_value   = ["bg", "fg", "soft", "hard", "intr", "posix", "cto", "ac",
			    "lock", "tcp", "udp",
			    // these are common for all fs types
			    "atime", "auto", "dev", "exec", "suid", "user"];
	// these cannot be negated
	list non_value1 = ["defaults", "async", "sync", "ro", "rw"];
	list with_value  = ["rsize", "wsize", "timeo", "retrans", "acregmin", "acregmax",
			    "acdirmin", "acdirmin", "acdirmax", "actimeo", "retry", "namlen",
			    "port", "mountport", "mountport", "mounthost", "mountprog",
			    "mountvers", "nfsprog", "nfsvers"];
	integer i = 0;
	string current_option = "";

	// first fiter out non value options and its nooptions forms (see nfs(5))
	option_list = filter (`e, option_list, ``(!contains (non_value, e)));
	non_value   = maplist (`e, non_value, ``(sformat ("no%1", e)));
	option_list = filter (`e, option_list, ``(!contains (non_value, e)));
	option_list = filter (`e, option_list, ``(!contains (non_value1, e)));

	while (i < size (option_list))
	{
	    string opt = select (option_list, i, "");
	    list(string) value = splitstring (opt, "=");
	    string v0 = select (value, 0, "");
	    string v1 = select (value, 1, "");
	    // To translators: error popup
	    if (!contains (with_value, v0)) return sformat (_("Wrong option: %1"), v0);
	    // To translators: error popup
	    if (size (value) != 2) return sformat (_("Wrong option format: %1"), opt);
	    if (v1 == "") return sformat (_("Empty value for option: %1"), v0);
	    i = i + 1;
	}

	return "";
    }

    /**
     * Strips a superfluous slash off the end of a pathname.
     * @param	p	pathname
     * @return		stripped pathname
     */
    global define string StripExtraSlash (string p) ``{
	if (regexpmatch (p, "^.+/$"))
	{
	    return regexpsub (p, "^(.+)/$", "\\1");
	}
	else
	{
	    return p;
	}
    }
}
