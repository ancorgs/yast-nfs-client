/**
 * File:
 *   routines.ycp
 *
 * Module:
 *   Configuration of nfs
 *
 * Summary:
 *   Network NFS routines
 *
 * Authors:
 *   Jan Holesovsky <kendy@suse.cz>
 *   Dan Vesely <dan@suse.cz>
 *
 * $Id$
 *
 * Network NFS routines
 *
 */

{
    textdomain "nfs";

    include "ui/common_popups.ycp";

    /**
     * Creates a list of ui table items for nfs fstab entries 
     * @param fstab list of nfs fstab entries
     * @return list itemized table entries
     * @example UI(`ChangeWidget(`id(`fstable), `Items, FstabTableItems(nfs_fstab)));
     */
    global define FstabTableItems(list fstab) ``{
        integer count = 0;
        return maplist(`entry, fstab, ``{
            term sp = SpecToServPath(lookup(entry, "spec"));
            term it = `item(`id(count), select(sp, 0)+" ", select(sp, 1)+" ",
                            lookup(entry, "file")+" ", lookup(entry, "mntops")+" ");
            
            count = count+1;
            return it;
        });
    }

    /**
     * @param spec	"server:/path/specification"
     * @return term	`couple("server", "/path/specification")
     */
    global define SpecToServPath(string spec) ``{
        integer colonpos = findfirstof(spec, ":");
        string serv = "";
        if (colonpos != nil) {
            serv = substring(spec, 0, colonpos);
            spec = substring(spec, colonpos+1);
        }
        return `couple(serv, spec);
    }
    

    /** 
     * Check for the validity of a hostname: nonempty, shorter than 50 chars,
     * [-A-Za-z._]. If invalid, a message is displayed.
     * @param name	a hostname
     * @return boolean 	whether valid
     */
    global define CheckHostName(string name) ``{
        if (size(name) > 0 && 
            size(name) < 50 &&
            name == filterchars(name,
                                "-_.0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")) {
            return true;
        } else
	    // error popup message
            UI(`MessagePopup(sformat(UI(_("You entered a wrong host name. It must be
shorter than 50 characters and you can use
just 0..9, A..Z, a..z, dots, - and _.")))));
        return false;
    };

    /**
     * Check for the validity of mount options:
     * nonempty, fewer than 70 chars, [0-9a-z=] no blanks.
     * If invalid, a message is displayed.
     * @param name	comma delimited options
     * @return boolean	whether valid
     */
    global define CheckOptions(string name) ``{
        
        list keywords = ["async", "atime", "defaults", "dev", "exec", "noatime", "noauto", "nodev", "noexec",
                        "nosuid", "nouser", "remount", "ro", "rw", "suid", "sync", "user", "uid", "gid",
                        "setuid", "setgid", "mode", "protect", "usemp", "verbose", "prefix", "volume", "reserved",
                        "root", "bs", "grpquota", "noquota", "quota", "usrquota", "bsddf", "minixdf", "check", "errors",
                        "grpid", "bsdgroups", "nogrpid", "sysvgroups", "resgid", ""];
        
        
        list names = splitstring (name, ",");
        boolean wrong = contains (maplist (`n, names, ``(findfirstnotof (n, "0123456789abcdefghijklmnopqrstuvwxyz=") != nil)), true);
        
        if (!wrong &&
            size(name) > 0 && 
            size(name) < 70 &&
            findfirstof(name, " \t") == nil)
            return true;
        else
	    // error popup message
            UI(`MessagePopup(sformat(UI(_("You entered a wrong options string.
It must be shorter than 70 characters 
and it must not contain spaces.")))));
        return false;
    };
    
    /**
     * Check if a mountpoint is in the fstab. If yes, display a message.
     * @param fstab	in .etc.fstab format
     * @param mpoint	mount point
     * @return boolean
     */
    global define IsMpInFstab(list fstab, string mpoint) ``{
        list tmp = filter(`fse, fstab, ``{
            return (lookup(fse, "file") == mpoint);
        });
        
        if (size(tmp) == 0)
            return false;
        else
	    // error popup message
            UI(`MessagePopup(sformat(UI(_("The fstab already contains an entry
with mount-point '%1'.")), mpoint)));
        return true;
    };
    
    // duplicated in nfs/routines.ycp and nfs_server/routines.ycp
    /**
     * Check for the validity of a path/mountpoint:
     * nonempty, fewer than 70 chars, no blanks, starts with a slash.
     * If invalid, a message is displayed.
     * @param name	path
     * @return boolean	whether valid
     */
    global define CheckPath(string name) ``{
        if (size(name) > 0 && 
            size(name) < 70 &&
            substring(name, 0, 1) == "/" &&
            findfirstof(name, " \t") == nil)
            return true;
        else
	    // error popup message
            UI(`MessagePopup(sformat(UI(_("You entered a wrong path. It must be
shorter than 70 characters, it must begin
with a / and it must not contain spaces.")))));
        return false;
    };

    /**
     * Checks the nfs options for /etc/fstab:
     * nonempty, comma separated list of foo,nofoo,bar=baz (see nfs(5))
     * @param options	options
     * @return locale	a locale with error message, emtpy string if ok
     */
    global define check_options (string options) ``{
        
        // To translators: error popup
        if (size (options) == 0)   return _("Empty options string not allowed!");
        if (options == "defaults") return "";
        

        list option_list = splitstring (options, ",");
        list non_value   = ["bg", "fg", "soft", "hard", "intr", "posix", "cto", "ac", 
                            "lock", "tcp", "udp", "defaults"];
        list with_value  = ["rsize", "wsize", "timeo", "retrans", "acregmin", "acregmax", 
                            "acdirmin", "acdirmin", "acdirmax", "actimeo", "retry", "namlen", 
                            "port", "mountport", "mountport", "mounthost", "mountprog", 
                            "mountvers", "nfsprog", "nfsvers"];
        integer i = 0;
        string current_option = "";

        // first fiter out non value options and its nooptions forms (see nfs(5))
        option_list = filter (`e, option_list, ``(!contains (non_value, e)));
        non_value   = maplist (`e, non_value, ``(sformat ("no%1", e)));
        option_list = filter (`e, option_list, ``(!contains (non_value, e)));
        
        while (i < size (option_list))
        {
            list value = splitstring (select (option_list, i), "=");
            // To translators: error popup
            if (size (value) != 2) return sformat (_("Wrong option format: %1"), select (option_list, i));
            // To translators: error popup
            if (!contains (with_value, select (value, 0))) return sformat (_("Wrong option: %1"), select (value, 0));
            if (size (select (value, 1)) == 0) return sformat (_("Empty value for option: %1"), select (value, 0));
            i = i + 1;
        }
     
        return "";
    }
}
